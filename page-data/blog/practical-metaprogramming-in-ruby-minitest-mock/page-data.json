{"componentChunkName":"component---src-templates-blog-post-js","path":"/blog/practical-metaprogramming-in-ruby-minitest-mock/","result":{"data":{"site":{"siteMetadata":{"title":"wasabigeek"}},"markdownRemark":{"id":"cf043ad0-ed1a-5967-b210-f82f85eb00ea","excerpt":"(repo) is a tiny mocking library (< 250 lines of code, including comments) that’s also a great showcase for how metaprogramming can be used in Ruby - let’s take…","html":"<p><code class=\"language-text\">minitest/mock</code> (<a href=\"https://github.com/seattlerb/minitest/blob/v5.15.0/lib/minitest/mock.rb\">repo</a>) is a tiny mocking library (&#x3C; 250 lines of code, <em>including</em> comments) that’s also a great showcase for how metaprogramming can be used in Ruby - let’s take a look! If you’re new-ish to Ruby, I hope this gives you concrete examples of what metaprogramming is possible, and how to do it.</p>\n<h2>What is metaprogramming?</h2>\n<p>In the context of this article, I’m referring to programs and code that are able to do <em>introspection</em> (inspect themselves e.g. type or properties) and <em>reflection</em> (modify their behaviour).</p>\n<h2>First example: Set expectations with method_missing</h2>\n<p>The main feature of <code class=\"language-text\">minitest/mock</code> is the <code class=\"language-text\">Minitest::Mock</code> class, which can be used to test that a method is called, for example:</p>\n<div class=\"gatsby-highlight\" data-language=\"ruby\"><pre class=\"language-ruby\"><code class=\"language-ruby\"><span class=\"token keyword\">require</span> <span class=\"token string\">'minitest/mock'</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">ClassUnderTest</span>\n  <span class=\"token keyword\">def</span> <span class=\"token method-definition\"><span class=\"token function\">initialize</span></span><span class=\"token punctuation\">(</span>foo<span class=\"token punctuation\">)</span>\n    <span class=\"token variable\">@foo</span> <span class=\"token operator\">=</span> foo\n  <span class=\"token keyword\">end</span>\n\n  <span class=\"token keyword\">def</span> <span class=\"token method-definition\"><span class=\"token function\">call</span></span>\n    <span class=\"token variable\">@foo</span><span class=\"token punctuation\">.</span>bar\n  <span class=\"token keyword\">end</span>\n<span class=\"token keyword\">end</span>\n\n<span class=\"token comment\"># create an instance of Mock and set an expectation</span>\n<span class=\"token comment\"># that the method `bar` will be called on it</span>\nmock_foo <span class=\"token operator\">=</span> <span class=\"token constant\">Minitest</span><span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span><span class=\"token constant\">Mock</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">new</span>\nmock_foo<span class=\"token punctuation\">.</span>expect<span class=\"token punctuation\">(</span><span class=\"token symbol\">:bar</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'example_return_value'</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># inject the mock into the Object-Under-Test</span>\n<span class=\"token comment\"># which essentially calls `mock_foo.bar`</span>\n<span class=\"token constant\">ClassUnderTest</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">new</span><span class=\"token punctuation\">(</span>mock_foo<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>call <span class=\"token comment\"># => returns 'example_return_value'</span>\n\n<span class=\"token comment\"># check that `bar` was called</span>\nmock_foo<span class=\"token punctuation\">.</span>verify</code></pre></div>\n<p>Notice that there’s nowhere in the library where the method <code class=\"language-text\">bar</code> is explicitly defined, yet running the above doesn’t raise a <code class=\"language-text\">NoMethodError</code>. We were able “define” (well, not exactly, but we’ll get to that) a new method <em>after</em> the mock object was already instantiated, via the <code class=\"language-text\">expect</code> call.</p>\n<p>The truth is <code class=\"language-text\">expect</code> (<a href=\"https://github.com/seattlerb/minitest/blob/v5.15.0/lib/minitest/mock.rb#L81-L92\">source code</a>) is straightforward Ruby; it saves the expected call to an Array instance variable - no new method gets defined. The real magic happens in <code class=\"language-text\">method_missing</code> :</p>\n<div class=\"gatsby-highlight\" data-language=\"ruby\"><pre class=\"language-ruby\"><code class=\"language-ruby\"><span class=\"token comment\"># lib/minitest/mock.rb#L118</span>\n<span class=\"token keyword\">def</span> <span class=\"token method-definition\"><span class=\"token function\">method_missing</span></span> sym<span class=\"token punctuation\">,</span> <span class=\"token operator\">*</span>args<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>block\n  <span class=\"token comment\"># ...</span>\n  expected_call <span class=\"token operator\">=</span> <span class=\"token variable\">@expected_calls</span><span class=\"token punctuation\">[</span>sym<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>index<span class=\"token punctuation\">]</span>\n  <span class=\"token comment\"># ...</span>\n  expected_args<span class=\"token punctuation\">,</span> retval<span class=\"token punctuation\">,</span> val_block <span class=\"token operator\">=</span> expected_call<span class=\"token punctuation\">.</span>values_at<span class=\"token punctuation\">(</span><span class=\"token symbol\">:args</span><span class=\"token punctuation\">,</span> <span class=\"token symbol\">:retval</span><span class=\"token punctuation\">,</span> <span class=\"token symbol\">:block</span><span class=\"token punctuation\">)</span>\n  <span class=\"token comment\"># ...</span>\n  <span class=\"token variable\">@actual_calls</span><span class=\"token punctuation\">[</span>sym<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span><span class=\"token operator\">&lt;</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token symbol\">:retval</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> retval<span class=\"token punctuation\">,</span>\n    <span class=\"token symbol\">:args</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> zipped_args<span class=\"token punctuation\">.</span>map<span class=\"token operator\">!</span> <span class=\"token punctuation\">{</span> <span class=\"token operator\">|</span>mod<span class=\"token punctuation\">,</span> a<span class=\"token operator\">|</span> mod <span class=\"token operator\">===</span> a <span class=\"token operator\">?</span> mod <span class=\"token punctuation\">:</span> a <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">end</span></code></pre></div>\n<p>If a method is called that doesn’t exist, Ruby will invoke <code class=\"language-text\">method_missing</code> with a few arguments:</p>\n<ul>\n<li>the method’s name in symbol form (<code class=\"language-text\">sym</code> in the above example)</li>\n<li>the arguments (<code class=\"language-text\">*args</code> ) and block (<code class=\"language-text\">&amp;block</code>) passed to the non-existent method</li>\n</ul>\n<p><code class=\"language-text\">Minitest::Mock</code> uses this to catch any undefined method that is called, checking it against the saved expectations. This makes it seem like the object has that method defined!</p>\n<h2>Remove inherited methods via undef_method</h2>\n<p>While <code class=\"language-text\">Minitest::Mock</code> doesn’t explicitly define many methods, it does inherit methods from Ruby’s <code class=\"language-text\">Object</code> class, such as <code class=\"language-text\">#nil?</code>.</p>\n<p>What if we want to check that a mock receives a method call, like <code class=\"language-text\">#nil?</code>? Without any intervention, <code class=\"language-text\">method_missing</code> would <em>not</em> be invoked, since those methods exist! Something like this would happen:</p>\n<div class=\"gatsby-highlight\" data-language=\"ruby\"><pre class=\"language-ruby\"><code class=\"language-ruby\">mock<span class=\"token punctuation\">.</span>expects<span class=\"token punctuation\">(</span><span class=\"token symbol\">:nil?</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span>\nmock<span class=\"token punctuation\">.</span><span class=\"token keyword\">nil</span><span class=\"token operator\">?</span> <span class=\"token comment\"># => false (this is the default for Object!)</span>\nmock<span class=\"token punctuation\">.</span>verify <span class=\"token comment\"># raises MockExpectationError, because the original `#nil?` method is called instead of `method_missing`!</span></code></pre></div>\n<p>So what the library does here is to undefine them when the class is interpreted. <code class=\"language-text\">instance_methods</code> is used to introspect the class for any instance methods, which are removed via <code class=\"language-text\">undef_method</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"ruby\"><pre class=\"language-ruby\"><code class=\"language-ruby\"><span class=\"token comment\"># lib/minitest/mock.rb#L26</span>\ninstance_methods<span class=\"token punctuation\">.</span><span class=\"token keyword\">each</span> <span class=\"token keyword\">do</span> <span class=\"token operator\">|</span>m<span class=\"token operator\">|</span>\n  undef_method m <span class=\"token keyword\">unless</span> overridden_methods<span class=\"token punctuation\">.</span><span class=\"token keyword\">include</span><span class=\"token operator\">?</span><span class=\"token punctuation\">(</span>m<span class=\"token punctuation\">.</span>to_s<span class=\"token punctuation\">)</span> <span class=\"token operator\">||</span> m <span class=\"token operator\">=</span><span class=\"token operator\">~</span> <span class=\"token regex\">/^__/</span>\n<span class=\"token keyword\">end</span></code></pre></div>\n<p>Calling <code class=\"language-text\">#nil?</code> now would properly invoke <code class=\"language-text\">method_missing</code>.</p>\n<h2>Redefining Methods with define_method</h2>\n<p>In the code above, we saw that not all <code class=\"language-text\">instance_methods</code> were removed, there are some <code class=\"language-text\">overridden_methods</code> (e.g. <code class=\"language-text\">inspect</code>) where the library opts to keep the default implementation <em>unless</em> the user has explicitly set an expectation. This is done by re-defining them via <code class=\"language-text\">define_method</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"ruby\"><pre class=\"language-ruby\"><code class=\"language-ruby\"><span class=\"token comment\"># lib/minitest/mock.rb#L30</span>\noverridden_methods<span class=\"token punctuation\">.</span>map<span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span><span class=\"token symbol\">:to_sym</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">each</span> <span class=\"token keyword\">do</span> <span class=\"token operator\">|</span>method_id<span class=\"token operator\">|</span>\n  <span class=\"token keyword\">define_method</span> method_id <span class=\"token keyword\">do</span> <span class=\"token operator\">|</span><span class=\"token operator\">*</span>args<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>b<span class=\"token operator\">|</span>\n    <span class=\"token keyword\">if</span> <span class=\"token variable\">@expected_calls</span><span class=\"token punctuation\">.</span>key<span class=\"token operator\">?</span> method_id <span class=\"token keyword\">then</span>\n      method_missing<span class=\"token punctuation\">(</span>method_id<span class=\"token punctuation\">,</span> <span class=\"token operator\">*</span>args<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>b<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">else</span>\n      <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>args<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>b<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">end</span>\n  <span class=\"token keyword\">end</span>\n<span class=\"token keyword\">end</span></code></pre></div>\n<p>The goal seems to be so that a <code class=\"language-text\">Minitest::Mock</code> instance still responds like a Ruby object e.g. when printing it in the terminal 😄.</p>\n<h2>Stubbing by redefining methods on “Metaclasses”</h2>\n<p><code class=\"language-text\">minitest/mock</code> also has a stubbing feature, which allows you to redefine the return value of an object within a block:</p>\n<div class=\"gatsby-highlight\" data-language=\"ruby\"><pre class=\"language-ruby\"><code class=\"language-ruby\"><span class=\"token builtin\">Time</span><span class=\"token punctuation\">.</span>stub<span class=\"token punctuation\">(</span><span class=\"token symbol\">:now</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"example\"</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">do</span>\n  <span class=\"token builtin\">Time</span><span class=\"token punctuation\">.</span>now <span class=\"token comment\"># => \"example\"</span>\n<span class=\"token keyword\">end</span>\n<span class=\"token builtin\">Time</span><span class=\"token punctuation\">.</span>now <span class=\"token comment\"># => actual time...</span></code></pre></div>\n<p>Let’s look at the implementation - the library first opens the <code class=\"language-text\">Object</code> class, and defines a <code class=\"language-text\">stub</code> method there:</p>\n<div class=\"gatsby-highlight\" data-language=\"ruby\"><pre class=\"language-ruby\"><code class=\"language-ruby\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Object</span>\n  <span class=\"token comment\"># lib/minitest/mock.rb#L214</span>\n  <span class=\"token keyword\">def</span> <span class=\"token method-definition\"><span class=\"token function\">stub</span></span> name<span class=\"token punctuation\">,</span> val_or_callable<span class=\"token punctuation\">,</span> <span class=\"token operator\">*</span>block_args\n    <span class=\"token comment\"># ...</span>\n  <span class=\"token keyword\">end</span>\n<span class=\"token keyword\">end</span></code></pre></div>\n<p>Since <code class=\"language-text\">Object</code> is the ancestor of all almost everything in Ruby (including Classes and Modules), we are able to call <code class=\"language-text\">stub</code> on basically anything. The actual implementation of <code class=\"language-text\">stub</code> is the interesting bit, introducing us to Ruby’s “metaclasses” (also known as “singleton classes” or “eigenclasses”):</p>\n<div class=\"gatsby-highlight\" data-language=\"ruby\"><pre class=\"language-ruby\"><code class=\"language-ruby\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Object</span>\n  <span class=\"token comment\"># lib/minitest/mock.rb#L214</span>\n  <span class=\"token keyword\">def</span> <span class=\"token method-definition\"><span class=\"token function\">stub</span></span> name<span class=\"token punctuation\">,</span> val_or_callable<span class=\"token punctuation\">,</span> <span class=\"token operator\">*</span>block_args\n    new_name <span class=\"token operator\">=</span> <span class=\"token string\">\"__minitest_stub__<span class=\"token interpolation\"><span class=\"token delimiter tag\">#{</span>name<span class=\"token delimiter tag\">}</span></span>\"</span>\n\n    metaclass <span class=\"token operator\">=</span> <span class=\"token keyword\">class</span> <span class=\"token operator\">&lt;</span><span class=\"token operator\">&lt;</span> <span class=\"token keyword\">self</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">self</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">end</span>\n    <span class=\"token comment\"># ...</span>\n    metaclass<span class=\"token punctuation\">.</span>send <span class=\"token symbol\">:alias_method</span><span class=\"token punctuation\">,</span> new_name<span class=\"token punctuation\">,</span> name\n\n    metaclass<span class=\"token punctuation\">.</span>send <span class=\"token symbol\">:define_method</span><span class=\"token punctuation\">,</span> name <span class=\"token keyword\">do</span> <span class=\"token operator\">|</span><span class=\"token operator\">*</span>args<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>blk<span class=\"token operator\">|</span>\n      <span class=\"token comment\"># return or execute val_or_callable</span>\n    <span class=\"token keyword\">end</span>\n\n    <span class=\"token comment\"># ...</span>\n    <span class=\"token keyword\">yield</span> <span class=\"token keyword\">self</span>\n  <span class=\"token keyword\">ensure</span>\n    <span class=\"token comment\"># cleanup...</span>\n  <span class=\"token keyword\">end</span>\n<span class=\"token keyword\">end</span></code></pre></div>\n<p>There’s some further reading on metaclasses and that mysterious <code class=\"language-text\">class &lt;&lt; self</code> syntax in the footnotes, but one way to understand the above is to replace the following lines:</p>\n<div class=\"gatsby-highlight\" data-language=\"ruby\"><pre class=\"language-ruby\"><code class=\"language-ruby\">metaclass <span class=\"token operator\">=</span> <span class=\"token keyword\">class</span> <span class=\"token operator\">&lt;</span><span class=\"token operator\">&lt;</span> <span class=\"token keyword\">self</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">self</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">end</span>\nmetaclass<span class=\"token punctuation\">.</span>send <span class=\"token symbol\">:define_method</span><span class=\"token punctuation\">,</span> name <span class=\"token keyword\">do</span> <span class=\"token operator\">|</span><span class=\"token operator\">*</span>args<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>blk<span class=\"token operator\">|</span>\n  <span class=\"token comment\"># ...</span>\n<span class=\"token keyword\">end</span></code></pre></div>\n<p>…with:</p>\n<div class=\"gatsby-highlight\" data-language=\"ruby\"><pre class=\"language-ruby\"><code class=\"language-ruby\"><span class=\"token keyword\">def</span> <span class=\"token method-definition\"><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span><span class=\"token function\">name</span></span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>args<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>blk<span class=\"token punctuation\">)</span>\n  <span class=\"token comment\"># ...</span>\n<span class=\"token keyword\">end</span></code></pre></div>\n<p>In other words, <code class=\"language-text\">stub</code> is defining (or overwriting) the method on the object - the type of method (class/instance) being neatly handled by accessing the metaclass. (Note: <code class=\"language-text\">self.define_method</code> would not work for class methods, since <code class=\"language-text\">self</code> returns the class, it would define instance methods.)</p>\n<p>The original logic is kept safe by renaming it via <code class=\"language-text\">alias_method</code>, and in the <code class=\"language-text\">ensure</code> block, there is code to reverse this change. These ensure stubbing only takes effect in the stub block.</p>\n<h2>Footnotes</h2>\n<p>Note that metaprogramming, while powerful, comes with a performance and readability cost. Use with care!</p>\n<p>For further reading on various topics touched in this article, check these out:</p>\n<ul>\n<li><a href=\"https://martinfowler.com/articles/mocksArentStubs.html\">Mocks aren’t Stubs</a> by Martin Fowler</li>\n<li>Notes on <a href=\"https://cs.lmu.edu/~ray/notes/metaprogramming/\">Metaprogramming</a> by Ray Toal</li>\n<li>\n<p>Ruby metaclasses:</p>\n<ul>\n<li><a href=\"https://www.toptal.com/ruby/ruby-metaprogramming-cooler-than-it-sounds\">Ruby Metaprogramming Is Even Cooler Than It Sounds</a> by Nikola Todorovic</li>\n<li><a href=\"https://medium.com/@leo_hetsch/demystifying-singleton-classes-in-ruby-caf3fa4c9d91\">Diving into Ruby Singleton Classes</a> by Léonard Hetsch</li>\n<li><a href=\"https://yehudakatz.com/2009/11/15/metaprogramming-in-ruby-its-all-about-the-self/\">Metaprogramming in Ruby: It’s All About the Self</a> by Yehuda Katz</li>\n</ul>\n</li>\n</ul>","frontmatter":{"title":"Practical Metaprogramming in Ruby: minitest/mock","date":"January 22, 2022","description":"minitest/mock is a tiny library that nevertheless provides a wealth of examples for metaprogramming in Ruby - let's take a look!"}}},"pageContext":{"slug":"/blog/practical-metaprogramming-in-ruby-minitest-mock/","previous":{"fields":{"slug":"/blog/mocking-in-rspec-and-minitest-cheatsheat/"},"frontmatter":{"title":"Mocking in RSpec VS Minitest: A Cheatsheet"}},"next":null}},"staticQueryHashes":["1003244115","2841359383"]}