{"componentChunkName":"component---src-templates-blog-post-js","path":"/blog/why-is-polymorphism-important/","result":{"data":{"site":{"siteMetadata":{"title":"wasabigeek"}},"markdownRemark":{"id":"b69f0811-eeb7-567d-afea-d7aee3d4da38","excerpt":"When I first came across the concept of Polymorphism in Object-Oriented Programming (OOP), it wasn’t obvious to me why it was important. The top search results…","html":"<p>When I first came across the concept of Polymorphism in Object-Oriented Programming (OOP), it wasn’t obvious to me <em>why</em> it was important. The top search results generally explain <em>what</em> it is and <em>how</em> to use it, but handwave the <em>why</em> and treat it as yet-another-language-feature. </p>\n<p>A <a href=\"https://blog.cleancoder.com/uncle-bob/2018/04/13/FPvsOO.html\">blog post</a> by Robert Martin (who coined the SOLID acronym) caught my eye recently, in particular this statement:</p>\n<blockquote>\n<p>…the thing that truly differentiates OO programs from non-OO programs is polymorphism.</p>\n</blockquote>\n<p>Whoa! Now he doesn’t mean that encapsulation, inheritance and other concepts associated with OOP are not important, but argues that they are achievable in “non-OOP” as well. Still, I wondered why most material skims over something that he considered core to OOP. Could we build a stronger intuition for <em>why</em> polymorphism is important?</p>\n<h2>What is polymorphism?</h2>\n<p>Let’s set the stage by aligning on what Polymorphism in OOP is. In the same post, Martin explains Polymorphism as different kinds of objects being able to accept the same message, implementing their own behaviour. I’ll paraphase his example:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">some_object.do_the_right_thing(input)</code></pre></div>\n<p>We don’t actually know what <code class=\"language-text\">some_object</code> is! Many different implementations could replace <code class=\"language-text\">some_object</code>, and the program would still run as long as they had the same interface (i.e. have the method <code class=\"language-text\">#do_the_right_thing</code>).</p>\n<h2>Why polymorphism?</h2>\n<p>In another <a href=\"https://blog.cleancoder.com/uncle-bob/2014/11/24/FPvsOO.html\">blog post</a>, Martin says:</p>\n<blockquote>\n<p>There really is only one benefit to Polymorphism; but it’s a big one. It is the inversion of source code and run time dependencies.</p>\n</blockquote>\n<p>Let’s concretise this with an example: caching in a web framework like Rails. There are multiple options out there for caches - for example, Rails supports a <code class=\"language-text\">FileStore</code>, a <code class=\"language-text\">MemCacheStore</code> and a <code class=\"language-text\">RedisCacheStore</code>. For the sake of illustration, imagine that the caches all had their own interfaces:</p>\n<div class=\"gatsby-highlight\" data-language=\"ruby\"><pre class=\"language-ruby\"><code class=\"language-ruby\"><span class=\"token keyword\">def</span> <span class=\"token method-definition\"><span class=\"token function\">example_method</span></span>\n  <span class=\"token comment\"># do stuff</span>\n  <span class=\"token keyword\">if</span> <span class=\"token constant\">Rails</span><span class=\"token punctuation\">.</span>cache<span class=\"token punctuation\">.</span>is_a<span class=\"token operator\">?</span> <span class=\"token constant\">NaiveFileStore</span>\n    data <span class=\"token operator\">=</span> <span class=\"token constant\">Rails</span><span class=\"token punctuation\">.</span>cache<span class=\"token punctuation\">.</span>search_for<span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">elsif</span> <span class=\"token constant\">Rails</span><span class=\"token punctuation\">.</span>cache<span class=\"token punctuation\">.</span>is_a<span class=\"token operator\">?</span> <span class=\"token constant\">NaiveRedisCacheStore</span>\n    data <span class=\"token operator\">=</span> <span class=\"token constant\">Rails</span><span class=\"token punctuation\">.</span>cache<span class=\"token punctuation\">.</span>get<span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">end</span>\n  <span class=\"token comment\"># do not stuff</span>\n<span class=\"token keyword\">end</span></code></pre></div>\n<p>Above, our <code class=\"language-text\">example_method</code> has a direct dependency on <code class=\"language-text\">NaiveFileStore</code> and <code class=\"language-text\">NaiveRedisCacheStore</code>. If their interfaces change, or new kinds of stores are supported, it will require changes in <code class=\"language-text\">example_method</code>.</p>\n<p>Martin talks about an inversion of dependencies (D in SOLID) - practically this means  <code class=\"language-text\">example_method</code> and the different cache stores instead depend on an agreed interface. This makes all cache stores polymorphic! In Rails all <a href=\"https://guides.rubyonrails.org/caching_with_rails.html#activesupport-cache-store\">cache stores</a> implement a <code class=\"language-text\">#fetch</code> method, so the above becomes:</p>\n<div class=\"gatsby-highlight\" data-language=\"ruby\"><pre class=\"language-ruby\"><code class=\"language-ruby\"><span class=\"token keyword\">def</span> <span class=\"token method-definition\"><span class=\"token function\">example_method</span></span>\n  <span class=\"token comment\"># do stuff</span>\n  data <span class=\"token operator\">=</span> <span class=\"token constant\">Rails</span><span class=\"token punctuation\">.</span>cache<span class=\"token punctuation\">.</span>fetch<span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span>\n  <span class=\"token comment\"># do not stuff</span>\n<span class=\"token keyword\">end</span></code></pre></div>\n<p>The code in <code class=\"language-text\">example_method</code> is more concise now, but that’s a side benefit; what’s important is it’s shielded from knowledge which exact cache store is used, and how the store works. It just knows that <em>some</em> cache store exists (<code class=\"language-text\">Rails.cache</code>), and the cache store has agreed to implement <code class=\"language-text\">#fetch</code> method.</p>\n<p>We can visualise the new “dependency directions” changing with the arrows below:\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 501px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/a99ebb7855eee46e02e449256eb4b2af/55811/polymorphic.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 78.37837837837837%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAYAAAAWGF8bAAAACXBIWXMAAAsSAAALEgHS3X78AAABuUlEQVQ4y32Ux87CQAyE8/4vwSNw5gISEuUAohxAIA703nufX59/GaGIxNLIG8c7O/Y6CTKZjNLptLLZrFj3ej2t12tNp1PzUfZ+v3/Gg8PhoMvlotvtpvP5rO12q81mo91up8ViodPpZO8cPJMfRRq8Xi89n089Hg+x9kQ2zedz8/1+35QPh0MjPR6PlvOTkA0oA/v9/qPwfr+bhwDvIA5hpMJut6vJZGIqvFTUYmymxOv1+gFk+EhCCFAV9pBRMpcDZrOZeWLkRBISpHcODIW0gJ6NRiPz4/HYPMSxhIox+kd5Yf99y2EEqCGREgFr72HYmAYQZ0Eul1OpVFKlUlGxWBTPtVpNq9XKBpubx3NhbrTmezYdxAN645tpOMO8XC7N+9dC38hxo2wO8pHzCUBMbA/DnxpgjFBL6ZC12+3PYclkUsFgMDAl3CCqSGZsKKFeryufz6vT6dgG5tXnkDzWKAUcVCgUFHg5kPHCh5tYuVy2MlqtlsXJpUwujWcUQgQgbzQaClDiPwde+Dz6yWziB8IaZaz9U6UyDkY5E5JKpf4H+xtxvyY3qqEdTEO1WjU0m00lEgn9Af9XzZvvQfc2AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"polymorphic.png\"\n        title=\"polymorphic.png\"\n        src=\"/static/a99ebb7855eee46e02e449256eb4b2af/55811/polymorphic.png\"\n        srcset=\"/static/a99ebb7855eee46e02e449256eb4b2af/12f09/polymorphic.png 148w,\n/static/a99ebb7855eee46e02e449256eb4b2af/e4a3f/polymorphic.png 295w,\n/static/a99ebb7855eee46e02e449256eb4b2af/55811/polymorphic.png 501w\"\n        sizes=\"(max-width: 501px) 100vw, 501px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p>Martin describes this as a “plugin architecture”:</p>\n<blockquote>\n<p>This inversion allows the called module to act like a plugin. Indeed, this is how all plugins work.\n…\nPlugin architectures are very robust because stable high value business rules can be kept from depending upon volatile low value modules such as user interfaces and databases.</p>\n</blockquote>\n<p>With the new setup, the polymorphic cache stores can be swapped for each other without changing the code in <code class=\"language-text\">example_method</code>. New kinds of cache stores can also be supported by creating classes that have <code class=\"language-text\">#fetch</code>, for example by inheriting from the abstract <a href=\"https://guides.rubyonrails.org/caching_with_rails.html#activesupport-cache-store\">ActiveSupport::Cache::Store</a>.</p>","frontmatter":{"title":"Why is Polymorphism important?","date":"March 20, 2022","description":"When I first came across the concept of Polymorphism in Object-Oriented Programming, it wasn't obvious why it was important. Could we develop a better intuition for it's importance?"}}},"pageContext":{"slug":"/blog/why-is-polymorphism-important/","previous":{"fields":{"slug":"/blog/what-does-a-1972-paper-have-to-do-with-the-single-responsibility-principle/"},"frontmatter":{"title":"A 1972 paper and the Single Responsibility Principle"}},"next":null}},"staticQueryHashes":["1003244115","2841359383"]}