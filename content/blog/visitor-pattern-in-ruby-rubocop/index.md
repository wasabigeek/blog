---
title: "Visitor Pattern in Ruby: Examples from Rubocop"
date: "2022-08-09"
description: "The visitor design pattern separates the operation to be performed from the object structure. We look at a concrete implementation in Rubocop, a Ruby linting and formatting library."
published: false
tags: ["design-patterns", "software-design"]
---
 In this post, we'll learn about the Visitor design pattern and it's tradeoffs by looking at a real world example: Rubocop, a Ruby linting[^2] and formatting library.
 
[^2]: A tool that checks raw source code against a set of rules e.g. for common errors or conformance to a style guide. See [Wikipedia](https://en.m.wikipedia.org/wiki/Lint_(software)).

## What is the Visitor design pattern?
The visitor design pattern separates the operation to be performed from a complex object structure (e.g. a tree whose nodes have many types).

![visitor.png](./visitor.png)

This makes it easier to introduce new operations ("visitors") for the same structure, at the cost that introducing new node types requires all visitors to be changed. So this pattern works best when changes to the underlying structure are rare, and we expect many different operations to be introduced.

The pattern does not dictate a single way to implement traversal of the object structure. In our examples, we'll see a mix of approaches.

## Rubocop
In Rubocop, each linting rule is called a "cop" and follows a visitor-inspired pattern. In particular, the pattern enables these features[^3]:

[^3]: Taken from Rubocop's [feature list](https://docs.rubocop.org/rubocop/1.33/index.html)
- "Ability to disable certain cops only for specific files or parts of files"
- "Itâ€™s easy to extend RuboCop with custom cops and formatters"

Now, Rubocop doesn't follow the classical visitor implementation[^4], but separates concerns similarly. We'll look at how the pattern is implemented, before looking at how it powers each of the above features.

[^4]: See class diagram in [Design Patterns book](https://www.amazon.com/Design-Patterns-Object-Oriented-Addison-Wesley-Professional-ebook/dp/B000SEIBB8), or on [refactoring.guru](https://refactoring.guru/design-patterns/visitor#structure).

### Object Structure: Abstract Syntax Tree (AST)
Before running any cops, Rubocop first uses the [parser](https://github.com/whitequark/parser) library to create a tree representation of code. This makes the responsibility of cops much simpler: they don't have to worry about syntax correctness, and because code is pre-grouped and categorised in the tree, it's easier to know when a linting rule should be triggered.

Let's look at a simple example (try it in `irb`!):
```ruby
code_string = <<~CODE
  private def sum(a, b)
    a + b
  end

  sum(1, 2)
CODE
# => "private def sum(a, b)\n a + b\nend\n\nsum(1, 2)\n"
```

The AST generated by `parser` looks like this in textual form:
```ruby
require 'parser/current'
Parser::CurrentRuby.parse(code_string)
# =>
# s(:begin,
#   s(:send, nil, :private,
#     s(:def, :sum,
#       s(:args,
#         s(:arg, :a),
#         s(:arg, :b)),
#       s(:send,
#         s(:lvar, :a), :+,
#         s(:lvar, :b))),
#   s(:send, nil, :sum,
#     s(:int, 1),
#     s(:int, 2)))
```

The AST breaks down the code into relevant constructs based on Ruby's syntax - see [here](https://github.com/whitequark/parser/blob/master/doc/AST_FORMAT.md) for a list of `parser`'s node types ðŸ¤¯. We can visualize the above:

![ruby_ast_example.png](./ruby_ast_example.png)

For now, knowing that the object structure is basically a tree, so don't worry too much if you don't understand how it works. (For a good overview of how this AST fits into the Ruby interpretation process, check out this [great video](https://youtu.be/ySuMOEVLaMw) by [@OngMaple](https://twitter.com/OngMaple). Also, notice how things like spaces and line breaks are not represented in the tree itself - hence, "abstract" syntax.)

### Visitor: Cops
Each linting or formatting rule in Rubocop is encapsulated in a "cop", which is essentially a visitor. For example, let's look at the [DefEndAlignment](https://github.com/rubocop/rubocop/blob/master/lib/rubocop/cop/layout/def_end_alignment.rb) cop. By default, this checks that `end` is aligned to `def` at the start of the line, e.g.:
```ruby
# bad
def foo
    end

# good
def foo
end
```

 Each cop defines `on_#{node_type}` methods, which the traversal mechanism will call when it hits a corresponding AST node. We can see the cop handles 3 node types, `on_def`, `on_defs` and `on_send`:
```ruby
def on_def(node)
  # ...
end
alias on_defs on_def

def on_send(node)
  # ...
end
```

(`on_send` might seem out-of-place - it's for handling "def modifiers" e.g. `private` in `private def foo`.)

If you recall the AST from before, there weren't any `end` nodes, and the structure itself left out indentations and spaces. So how does this linter work? Turns out that `parser` nodes still contain information about the source code (e.g. positions), and cops can use this in tandem with the original source code for linting.

Of note: this cop also does it's own little traversal for `on_send`. This is because the `send` node contains the start position of the `private` keyword, but the position of `end` is still in the  `def` node. Thus, the code accesses [descendants](https://github.com/rubocop/rubocop/blob/133ffce3d3179f6cf2d7750da2a2da0add8c7e41/lib/rubocop/cop/layout/def_end_alignment.rb#L51) to look for the actual `def` node. From our previous example:

![on_send_def_traversal.png](./on_send_def_traversal.png)

Also, note that unlike the classical implementation, cops do not implement methods for all node types. Instead, there's logic that skips non-existent methods during traversal, which is a nice segue to our next section.

### Execution & Traversal
Object structure and visitors meet in the [Rubocop::Commissioner#investigate](https://github.com/rubocop/rubocop/blob/2fe4b1a6faca23adff13e1bbff6ecf5b66c6447b/lib/rubocop/cop/commissioner.rb#L79-L93) method. This method walks the tree and for each node, executes the respective `on_#{node_type}` method on all enabled cops.

The actual implementation is a little convoluted, with a fair amount of metaprogramming. It's a fun detour, but feel free to skip this! First, my attempt to visualise the flow with a sequence diagram:
![rubocop_traversal.png](./rubocop_traversal.png)
- when the `Commissioner` class is loaded, it loops through node types, defining "original" `on_#{node_type}` methods via `class_eval` ([source](https://github.com/rubocop/rubocop/blob/2fe4b1a6faca23adff13e1bbff6ecf5b66c6447b/lib/rubocop/cop/commissioner.rb#L59-L76)).
- `#investigate` will execute [#walk](https://github.com/rubocop/rubocop-ast/blob/5b53037d322275cdd5082e4164f976146cc6c014/lib/rubocop/ast/traversal.rb#L17-L22) (from an included `Rubocop::AST::Traversal` module) on the root node of the AST, which calls the corresponding "original" `on_#{node_type}` methods defined above.
- the "original" `on_#{node_type}` methods will execute every relevant cop for the node.
- the "original" `on_#{node_type}` methods will also execute `super`, which calls an "inherited" `on_#{node_type}` method (again defined in `Rubocop::AST::Traversal` via metaprogramming, see an example for [on_send](https://github.com/rubocop/rubocop-ast/blob/5b53037d322275cdd5082e4164f976146cc6c014/lib/rubocop/ast/traversal.rb#L154-L160)).
- the "inherited" method loops through child nodes, again invoking the original `on_#{node_type}` methods in Commissioner, this time with the child nodes.

I haven't dug up the *why* behind this particular design, my guess so far it (1) metaprogramming makes it easier to support new node types, and (2) this was a way to separate the traversal logic from the cop execution logic.

Note that the classical visitor implementation doesn't dictate where traversal logic should go. In Rubocop, the main traversal is separate from both object structure and visitors, but in other situations it might work better to put the logic in the object structure (or some parts of it, e.g. composite elements) or in the visitor itself (e.g. if different visitors need to traverse in a different order)[^5].

[^5]: See "Who is responsible for traversing the object structure?" in Visitor chapter,  [Design Patterns book](https://www.amazon.com/Design-Patterns-Object-Oriented-Addison-Wesley-Professional-ebook/dp/B000SEIBB8)

### Tradeoffs
Now that we know how Rubocop implements a visitor-inspired pattern, let's briefly examine the benefits and cost of the design.

Here are how the aforementioned Rubocop features are enabled by the visitor pattern:

> Ability to disable certain cops only for specific files or parts of files

Since linting and formatting logic is grouped by cops (visitors), it's easy to turn off or restrict the scope of a particular cop by excluding it during `#investogate`.

> Itâ€™s easy to extend RuboCop with custom cops and formatters

A new [custom cop](https://docs.rubocop.org/rubocop/1.33/development.html) can be created and enabled easily, without changes to the object structure or traversal logic.

In terms of costs, changes to the underlying object structure may ripple through all visitors. For example:
- If node categorisation changes, cops may no longer be checking correctly for those types. For example, in Ruby 3, how pattern matching was parsed [changed slightly](https://github.com/rubocop/rubocop/pull/9873). 
- If the hierarchy changes (e.g. new node types are introduced), it could break traversal. (Arguably, this can be mitigated through more abstract traversal e.g. [node pattern](https://docs.rubocop.org/rubocop-ast/node_pattern.html), which reminds me a lot of CSS selectors.)

Additionally, depending on the needs of visitors, objects in the structure may need to expose more information, potentially breaking encapsulation. In our example, Rubocop cops need to know about the positions of the node in the actual source code through methods like `#loc`, whereas a program that is just emulating Ruby and wants to execute the nodes does not.

## Afterword
I hope this helped concretise when and why you might want to use the visitor pattern. Here are some other examples you may want to look into:
- `nokogiri`, a XML/HTML parsing library, has a [CSS::XPathVisitor](https://github.com/sparklemotion/nokogiri/blob/148bdf5edc1f9963274b57ae899b4f651b53315b/lib/nokogiri/css/xpath_visitor.rb).
- `syntax-tree`, another Ruby parser, has [visitor support](https://github.com/ruby-syntax-tree/syntax_tree/blob/main/lib/syntax_tree/visitor.rb) (see [PR](https://github.com/ruby-syntax-tree/syntax_tree/pull/40/files))
  - `graphql-ruby`, a GraphQL parser, also has an [AST Visitor](https://graphql-ruby.org/language_tools/visitor.html)

