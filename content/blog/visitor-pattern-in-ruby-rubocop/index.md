---
title: "Visitor Pattern in Ruby: Rubocop"
date: "2022-08-09"
description: "The visitor design pattern separates the operation to be performed from the object structure. We look at a concrete implementation in Rubocop, a Ruby linting and formatting library."
published: false
tags: ["design-patterns", "software-design"]
---
In this post, we take a practical look at some Ruby implementations of the visitor pattern.

## What is the Visitor design pattern?
This design pattern separates the operation to be performed from a complex object structure (e.g. a tree whose nodes have many types).

`<insert diagram on separating tree and behaviour>`

This makes it easier to introduce new operations ("visitors") for the same structure, at the cost that introducing new node types requires all visitors to be changed. So this pattern works best when changes to the underlying structure are rare, and we expect many different operations to be introduced.

The pattern does not dictate a single way to implement traversal of the object structure. In our examples, we'll see a mix of approaches.

## Rubocop
Rubocop is a Ruby linting and formatting library where a visitor-inspired pattern is used to great effect. In particular, the pattern enables these features[^2]:
[^2]: Taken from Rubocop's [feature list](https://docs.rubocop.org/rubocop/1.33/index.html)
- "Ability to disable certain cops only for specific files or parts of files"
- "Itâ€™s easy to extend RuboCop with custom cops and formatters"

Rubocop doesn't follow the exact classical implementation[^3], but is similar in how it separates concerns. We'll look at how the pattern is implemented, before looking at how it powers each of the above features.

[^3:] See class diagram in [Design Patterns book](https://www.amazon.com/Design-Patterns-Object-Oriented-Addison-Wesley-Professional-ebook/dp/B000SEIBB8), or on [refactoring.guru](https://refactoring.guru/design-patterns/visitor#structure).

### Object Structure: Abstract Syntax Tree (AST)
Rubocop uses the [parser](https://github.com/whitequark/parser) library to create a tree representation of code. Let's look at a simple example:
```ruby
code_string = <<~CODE
  def sum(a, b)
    a + b
  end

  sum(1, 2)
CODE
# => "def sum(a, b)\n a + b\nend\n\nsum(1, 2)\n"
```

The AST generated by `parser` looks like this in textual form:
```ruby
require 'parser/current'
Parser::CurrentRuby.parse(code_string)
# =>
# s(:begin,
#   s(:def, :sum,
#     s(:args,
#       s(:arg, :a),
#       s(:arg, :b)),
#     s(:send,
#       s(:lvar, :a), :+,
#       s(:lvar, :b))),
#   s(:send, nil, :sum,
#     s(:int, 1),
#     s(:int, 2)))
```

The AST breaks down the code into relevant constructs based on Ruby's syntax - see [here](https://github.com/whitequark/parser/blob/master/doc/AST_FORMAT.md) for a list of `parser`'s node types ðŸ¤¯. We can visualize the above in tree form:

`<insert diagram>`

(Notice how things like spaces and line breaks are not represented in the tree itself - hence, "abstract" syntax.)

### Visitor: Cops
Each linting / formatting option in Rubocop is encapsulated in a "cop", which is itself a visitor. For example, let's look at the [DefEndAlignment](https://github.com/rubocop/rubocop/blob/master/lib/rubocop/cop/layout/def_end_alignment.rb) cop. In the default, this checks that `end` is aligned to `def` at the start of the line, e.g.:
```ruby
# bad
def foo
    end

# good
def foo
end
```

 Each cop defines `on_#{node_type}` methods, which the traversal mechanism will call when it hits a corresponding node. In the source, we can see the cop handles 3 node types, `on_def`, `on_defs` and `on_send`:
```ruby
def on_def(node)
  # ...
end
alias on_defs on_def

def on_send(node)
  # ...
end
```

(`on_send` is an interesting one, this handles "def modifiers" e.g. `private` in `private def foo`.)

If you recall the AST from before, there weren't any `end` nodes, and the structure itself left out indentations and spaces. So how does this linter work? Turns out that `parser` nodes still contain information about the source code (e.g. positions), and cops can use this in tandem with the original source code for linting.

Of note: this cop also does it's own traversal (albeit smaller than the main traversal). For example, `on_send` would be called on the `private` keyword, not on `def`, so the code accesses [descendants](https://github.com/rubocop/rubocop/blob/133ffce3d3179f6cf2d7750da2a2da0add8c7e41/lib/rubocop/cop/layout/def_end_alignment.rb#L51):
`<insert diagram of private nodes -> and highlight which descendants are checked>`

### Execution & Traversal
The main traversal logic is separate from both the object structure and visitors, mostly in the [Rubocop::Commissioner#investigate](https://github.com/rubocop/rubocop/blob/2fe4b1a6faca23adff13e1bbff6ecf5b66c6447b/lib/rubocop/cop/commissioner.rb#L79-L93) method. To summarise, this walks the tree and for each node, executes the respective `on_#{node_type}` method on all enabled cops. 

(There's a fair amount of metaprogramming and interesting use of `super`, but I'll leave that for a future article.)

### Tradeoffs
Now that we know how Rubocop implements a visitor-inspired pattern, let's briefly examine the benefits and cost of the design.

Here are how the aforementioned Rubocop features are enabled by the visitor pattern:

> Ability to disable certain cops only for specific files or parts of files

Since linting / formatting logic is grouped by cops (visitors), meaning it's easy to turn off or restrict the scope of a particular cop.

> Itâ€™s easy to extend RuboCop with custom cops and formatters

A new [custom cop](https://docs.rubocop.org/rubocop/1.33/development.html) can be created and enabled easily, without changes to the object structure or traversal logic (though some config via a .yml file is required).

`<WORK IN PROGRESS>`

In terms of costs, changes to the underlying object structure may ripple through all visitors:
- node types change
- hierarchy changes, which breaks traversal

Additionally, since the visitor is a separate, the objects in the structure may need to expose more information, potentially  breaking encapsulation.
- possibly talk about how rubocop-ast needs to implement it's own nodes to expose additional information

